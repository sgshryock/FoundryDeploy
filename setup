#!/bin/bash
set -e

REPO_URL="https://github.com/sgshryock/FoundryDeploy.git"

# Determine installation directory
# If we're already in a FoundryDeploy directory, use current directory
# Otherwise, use "FoundryDeploy" subdirectory
if [ "$(basename "$(pwd)")" = "FoundryDeploy" ]; then
    INSTALL_DIR="."
else
    INSTALL_DIR="FoundryDeploy"
fi

# Cleanup function for error handling
cleanup_on_error() {
    local exit_code=$?
    if [ $exit_code -ne 0 ]; then
        echo
        echo "[ERROR] Setup failed (exit code: $exit_code)"
        if [ -f .env.incomplete ]; then
            rm -f .env.incomplete
            echo "Cleaned up incomplete configuration"
        fi
        echo "Please fix the issue and run setup again"
    fi
    exit $exit_code
}

trap cleanup_on_error EXIT ERR

# Function to update the setup script in parent directory
update_setup_script() {
    # Only update if we're running from a parent directory setup script
    # (not running the setup script from within the repo itself)
    if [ -f "../setup" ] && [ "$(basename "$(pwd)")" = "FoundryDeploy" ]; then
        if ! cmp -s setup ../setup 2>/dev/null; then
            echo "[INFO] Updating setup script in parent directory..."
            cp setup ../setup
            chmod +x ../setup
            echo "[OK] Setup script updated"
        fi
    fi
}

echo "=== Foundry VTT Deployment Setup ==="
echo

# Check for required commands
check_command() {
    if command -v "$1" &> /dev/null; then
        echo "[OK] $1 is installed"
        return 0
    else
        echo "[MISSING] $1 is not installed"
        return 1
    fi
}

missing=0

echo "Checking dependencies..."
echo

check_command git || missing=1
check_command docker || missing=1
check_command nginx || missing=1
check_command openssl || missing=1
docker compose version &>/dev/null || {
    if command -v docker-compose &> /dev/null; then
        echo "[OK] docker-compose (legacy) is installed"
    else
        echo "[MISSING] docker compose is not installed"
        missing=1
    fi
}

echo

if [ $missing -eq 1 ]; then
    echo "Some dependencies are missing. Install them with:"
    echo
    echo "  # Debian/Ubuntu:"
    echo "  sudo apt update"
    echo "  sudo apt install -y git docker.io docker-compose-v2 nginx openssl"
    echo "  sudo usermod -aG docker \$USER"
    echo "  # Log out and back in for group changes to take effect"
    echo
    echo "  # Fedora:"
    echo "  sudo dnf install -y git docker docker-compose nginx openssl"
    echo "  sudo systemctl enable --now docker"
    echo "  sudo usermod -aG docker \$USER"
    echo
    echo "  # Arch:"
    echo "  sudo pacman -S git docker docker-compose nginx openssl"
    echo "  sudo systemctl enable --now docker"
    echo "  sudo usermod -aG docker \$USER"
    echo
    exit 1
fi

# Check if docker daemon is running
if ! docker info &> /dev/null; then
    echo "[ERROR] Docker daemon is not running"
    echo "  Start it with: sudo systemctl start docker"
    exit 1
fi
echo "[OK] Docker daemon is running"

echo

# Determine if we need to clone
needs_rebuild=false

if [ -f "compose.yml" ] && [ -f "setup" ]; then
    # We're already in the repo
    echo "[OK] Already in FoundryDeploy directory"

    # Check for updates - only prompt if .env exists (indicates previous setup)
    # If .env doesn't exist, this is initial setup - just pull latest
    echo "Checking for updates..."
    git fetch origin main 2>/dev/null || true

    if git rev-parse @{u} &>/dev/null; then
        LOCAL=$(git rev-parse @)
        REMOTE=$(git rev-parse @{u})

        if [ "$LOCAL" != "$REMOTE" ]; then
            if [ -f ".env" ]; then
                # Previous setup exists - prompt user
                echo "[INFO] Updates available"
                read -p "Pull latest updates? [Y/n]: " pull_updates
                pull_updates=${pull_updates:-Y}

                if [[ "$pull_updates" =~ ^[Yy]$ ]]; then
                    git pull origin main
                    echo "[OK] Updates pulled"
                    echo "[INFO] Docker Compose will automatically apply any configuration changes"
                else
                    echo "[INFO] Skipping updates"
                fi
            else
                # Initial setup - pull latest automatically
                echo "[INFO] Pulling latest version for initial setup..."
                git pull origin main
                echo "[OK] Repository updated"
            fi
        else
            echo "[OK] Already up to date"
        fi
    fi

    # Always sync setup script from repo to parent directory
    update_setup_script

elif [ "$INSTALL_DIR" != "." ] && [ -d "$INSTALL_DIR" ]; then
    # Directory exists, check if it's a valid repo
    cd "$INSTALL_DIR"

    if [ -d ".git" ]; then
        # It's a git repo - check if it's FoundryDeploy
        REPO_REMOTE=$(git config --get remote.origin.url 2>/dev/null || echo "")

        if [[ "$REPO_REMOTE" == *"FoundryDeploy"* ]] || [ -f "compose.yml" ]; then
            echo "[OK] FoundryDeploy directory exists"

            # Ensure we have all files (in case some were deleted)
            if [ ! -f "compose.yml" ] || [ ! -f "start" ] || [ ! -f "stop" ] || [ ! -f "logs" ]; then
                echo "[INFO] Some files are missing, restoring from repository..."
                git fetch origin main 2>/dev/null || true
                git reset --hard origin/main
                echo "[OK] Repository files restored"
            else
                # Check for updates - only prompt if .env exists (indicates previous setup)
                echo "Checking for updates..."
                git fetch origin main 2>/dev/null || true

                if git rev-parse @{u} &>/dev/null; then
                    LOCAL=$(git rev-parse @)
                    REMOTE=$(git rev-parse @{u})

                    if [ "$LOCAL" != "$REMOTE" ]; then
                        if [ -f ".env" ]; then
                            # Previous setup exists - prompt user
                            echo "[INFO] Updates available"
                            read -p "Pull latest updates? [Y/n]: " pull_updates
                            pull_updates=${pull_updates:-Y}

                            if [[ "$pull_updates" =~ ^[Yy]$ ]]; then
                                git pull origin main
                                echo "[OK] Updates pulled"
                                echo "[INFO] Docker Compose will automatically apply any configuration changes"
                            else
                                echo "[INFO] Skipping updates"
                            fi
                        else
                            # Initial setup - pull latest automatically
                            echo "[INFO] Pulling latest version for initial setup..."
                            git pull origin main
                            echo "[OK] Repository updated"
                        fi
                    else
                        echo "[OK] Already up to date"
                    fi
                fi
            fi

            # Always sync setup script from repo to parent directory
            update_setup_script
        else
            echo "[ERROR] Directory '$INSTALL_DIR' is a git repository but not FoundryDeploy"
            echo "       Please remove or rename this directory first"
            exit 1
        fi
    else
        # Not a git repo - reinitialize by cloning fresh
        echo "[INFO] Directory '$INSTALL_DIR' exists but is not a git repository"
        echo "       Removing and cloning FoundryDeploy repository..."
        cd ..
        rm -rf "$INSTALL_DIR"
        git clone "$REPO_URL" "$INSTALL_DIR"
        cd "$INSTALL_DIR"
        echo "[OK] Repository cloned"

        # Sync setup script from repo to parent directory
        update_setup_script
    fi
else
    # Clone fresh (only if not already in FoundryDeploy)
    if [ "$INSTALL_DIR" = "." ]; then
        # We're in FoundryDeploy but no git repo - check if directory has files
        if [ "$(ls -A .)" ]; then
            # Directory has files - can't clone, initialize git manually
            echo "[INFO] Directory is not empty. Initializing git repository..."
            # Remove any nested FoundryDeploy directory that might exist
            if [ -d "FoundryDeploy" ]; then
                echo "[INFO] Removing nested FoundryDeploy directory..."
                rm -rf "FoundryDeploy"
            fi
            git init
            git remote add origin "$REPO_URL"
            git fetch origin main
            git checkout -b main origin/main 2>/dev/null || git reset --hard origin/main
            echo "[OK] Repository initialized"
        else
            # Empty directory - can clone directly
            echo "Initializing FoundryDeploy repository in current directory..."
            git clone "$REPO_URL" .
        fi
    else
        # Clone into subdirectory
        echo "Cloning FoundryDeploy repository..."
        git clone "$REPO_URL" "$INSTALL_DIR"
        cd "$INSTALL_DIR"
    fi

    # Sync setup script from repo to parent directory
    update_setup_script
fi

echo

# Verify operational scripts exist (should be present from git)
echo "Verifying operational scripts..."

# Check that all required files are present
for script in start stop logs remove compose.yml .env.example; do
    if [ ! -f "$script" ]; then
        echo "[ERROR] Required file '$script' is missing from repository"
        echo "       This indicates a problem with the git repository"
        echo "       Try: rm -rf FoundryDeploy && ./setup"
        exit 1
    fi
done

# Ensure scripts are executable
chmod +x start stop logs remove
echo "[OK] Operational scripts verified"

# Validation functions
validate_non_empty() {
    local value=$1
    local field_name=$2
    if [ -z "$value" ]; then
        echo "[ERROR] $field_name cannot be empty"
        return 1
    fi
    return 0
}

validate_port() {
    local port=$1
    if ! [[ "$port" =~ ^[0-9]+$ ]] || [ "$port" -lt 1 ] || [ "$port" -gt 65535 ]; then
        echo "[ERROR] Port must be a number between 1 and 65535"
        return 1
    fi
    return 0
}

validate_hostname() {
    local hostname=$1
    # Allow hostname, FQDN, or IP address
    if ! [[ "$hostname" =~ ^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$ ]] && \
       ! [[ "$hostname" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
        echo "[ERROR] Invalid hostname format"
        return 1
    fi
    return 0
}

validate_version() {
    local version=$1
    # Allow empty (defaults to release), "release", "latest", or numeric
    if [ -n "$version" ] && ! [[ "$version" =~ ^(release|latest|[0-9]+)$ ]]; then
        echo "[ERROR] Version must be 'release', 'latest', or a number (e.g., 12, 13)"
        return 1
    fi
    return 0
}

# Ensure we're in the FoundryDeploy directory before checking for .env
# This handles both running from ~/setup and ~/FoundryDeploy/setup
CURRENT_DIR=$(basename "$(pwd)")
if [ "$CURRENT_DIR" != "FoundryDeploy" ] && [ -d "FoundryDeploy" ] && [ ! -f "compose.yml" ]; then
    # Not in FoundryDeploy, but subdirectory exists and we're not in the repo yet
    cd FoundryDeploy
elif [ "$CURRENT_DIR" != "FoundryDeploy" ] && [ ! -f "compose.yml" ]; then
    # Not in correct directory and can't find repo files
    echo "[ERROR] Not in FoundryDeploy directory and repository files not found"
    echo "       Current directory: $(pwd)"
    exit 1
fi

# Check for existing .env file
if [ -f .env ]; then
    echo
    echo "[INFO] An .env file already exists."
    echo "Options:"
    echo "  1) Use existing configuration (recommended for updates) - default"
    echo "  2) Reconfigure from scratch (current file will be backed up)"
    echo "  3) Abort setup"
    echo
    read -p "Choose [1/2/3] (default=1): " config_choice
    config_choice=${config_choice:-1}  # Default to option 1

    case $config_choice in
        1)
            echo "[OK] Using existing configuration"

            # Parse existing values from .env
            parse_env_value() {
                local key=$1
                grep -E "^${key}=" .env | cut -d'=' -f2- | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | sed 's/#.*//'
            }

            foundry_hostname=$(parse_env_value "FOUNDRY_HOSTNAME")
            system_hostname=$(hostname)

            # Check if hostname matches system hostname
            if [ -n "$foundry_hostname" ] && [ "$foundry_hostname" != "$system_hostname" ]; then
                echo
                echo "[NOTICE] Hostname mismatch detected:"
                echo "  Current system hostname: $system_hostname"
                echo "  Configured hostname in .env: $foundry_hostname"
                echo
                read -p "Update hostname to match system ($system_hostname)? [Y/n]: " update_hostname
                update_hostname=${update_hostname:-Y}

                if [[ "$update_hostname" =~ ^[Yy]$ ]]; then
                    # Update hostname in .env
                    sed -i.bak "s/^FOUNDRY_HOSTNAME=.*/FOUNDRY_HOSTNAME=$system_hostname/" .env
                    rm -f .env.bak
                    echo "[OK] Hostname updated to $system_hostname"

                    # Regenerate SSL certificate with new hostname
                    if [ -f /etc/nginx/certs/foundry.crt ] || [ -f /etc/nginx/certs/foundry.key ]; then
                        echo "Regenerating SSL certificate for new hostname..."
                        sudo openssl req -x509 -nodes -days 3650 -newkey rsa:2048 \
                            -keyout /etc/nginx/certs/foundry.key \
                            -out /etc/nginx/certs/foundry.crt \
                            -subj "/C=US/ST=State/L=City/O=Organization/CN=$system_hostname" \
                            2>/dev/null

                        # Reload nginx to use new certificate
                        if systemctl is-active --quiet nginx 2>/dev/null; then
                            sudo systemctl reload nginx
                        fi
                        echo "[OK] SSL certificate regenerated and nginx reloaded"
                    fi

                    foundry_hostname=$system_hostname
                else
                    echo "[INFO] Keeping configured hostname: $foundry_hostname"
                fi
            fi

            # Always ensure SYSTEM_HOSTNAME matches current system hostname
            echo
            echo "Updating system hostname in configuration..."
            if grep -q "^SYSTEM_HOSTNAME=" .env; then
                # Update existing SYSTEM_HOSTNAME
                sed -i.bak "s/^SYSTEM_HOSTNAME=.*/SYSTEM_HOSTNAME=$system_hostname/" .env
                rm -f .env.bak
            else
                # Add SYSTEM_HOSTNAME if it doesn't exist
                echo "" >> .env
                echo "# System hostname for Docker container (prevents license re-acknowledgement)" >> .env
                echo "SYSTEM_HOSTNAME=$system_hostname" >> .env
            fi
            echo "[OK] System hostname set to: $system_hostname"

            # Skip to container startup (don't prompt for config)
            skip_config=true
            ;;
        2)
            backup_file=".env.backup.$(date +%Y%m%d_%H%M%S)"
            cp .env "$backup_file"
            echo "[OK] Existing .env backed up to $backup_file"
            skip_config=false
            ;;
        3)
            echo "Setup aborted."
            exit 0
            ;;
        *)
            echo "Invalid choice. Aborting."
            exit 1
            ;;
    esac
else
    skip_config=false
fi

# Prompt for configuration if needed
if [ "$skip_config" = false ]; then
    echo
    echo "=== Configuration ==="
    echo
    echo "Enter your Foundry VTT account credentials."
    echo "These are used to download Foundry from your account."
    echo

    while true; do
        read -p "Foundry Username: " foundry_username
        validate_non_empty "$foundry_username" "Username" && break
    done

    while true; do
        read -sp "Foundry Password: " foundry_password
        echo
        validate_non_empty "$foundry_password" "Password" && break
    done

    echo
    while true; do
        read -p "Foundry Admin Key (password for the web UI): " foundry_admin_key
        validate_non_empty "$foundry_admin_key" "Admin key" && break
    done

    echo
    echo "Foundry Version:"
    echo "  - Press Enter for latest stable"
    echo "  - Or enter a major version number (e.g., 12, 13)"
    while true; do
        read -p "Version [latest]: " foundry_docker_tag
        if [ -z "$foundry_docker_tag" ] || [ "$foundry_docker_tag" = "latest" ]; then
            foundry_docker_tag="release"
        fi
        validate_version "$foundry_docker_tag" && break
    done

    echo
    # Auto-detect system hostname for mDNS
    system_hostname=$(hostname)
    echo "Hostname for this server:"
    echo "  - Detected system hostname: $system_hostname"
    echo "  - This hostname will work automatically via mDNS (no DNS setup needed)"
    echo "  - Or enter a different hostname (will require DNS/Pi-hole configuration)"
    echo
    while true; do
        read -p "Hostname [$system_hostname]: " foundry_hostname
        foundry_hostname=${foundry_hostname:-$system_hostname}
        validate_hostname "$foundry_hostname" && break
    done

    # Warn if using custom hostname
    if [ "$foundry_hostname" != "$system_hostname" ]; then
        echo
        echo "[NOTE] You chose '$foundry_hostname' instead of '$system_hostname'"
        echo "       This will require DNS configuration (like Pi-hole) to resolve."
        echo "       Without DNS, you'll need to use the server's IP address."
        echo
    fi

    read -p "Timezone [America/New_York]: " timezone
    timezone=${timezone:-America/New_York}

    # Detect UID/GID for proper file permissions in Docker
    foundry_uid=$(id -u)
    foundry_gid=$(id -g)

    # Create .env file
    echo
    echo "Creating configuration..."

    cat > .env.incomplete << EOF
# Foundry account credentials
FOUNDRY_USERNAME=$foundry_username
FOUNDRY_PASSWORD=$foundry_password

# Foundry admin access key for this server instance
FOUNDRY_ADMIN_KEY=$foundry_admin_key

# Foundry version (release = latest, or specify major version like 12, 13)
FOUNDRY_DOCKER_TAG=$foundry_docker_tag

# Container settings
CONTAINER_CACHE=/data/container_cache
CONTAINER_PRESERVE_CONFIG=true

TZ=$timezone

# Hostname for accessing Foundry in browser (can be custom)
FOUNDRY_HOSTNAME=$foundry_hostname

# System hostname for Docker container (prevents license re-acknowledgement)
SYSTEM_HOSTNAME=$system_hostname

# User/Group IDs for file permissions
FOUNDRY_UID=$foundry_uid
FOUNDRY_GID=$foundry_gid
EOF

    # Move to final location and set permissions
    mv .env.incomplete .env
    chmod 600 .env
    echo "[OK] .env file created with secure permissions (600)"
fi

#Configure nginx reverse proxy with HTTPS
echo
echo "=== Configuring nginx with HTTPS ==="
echo

# Create nginx certs directory if it doesn't exist
sudo mkdir -p /etc/nginx/certs

# Check if SSL certificate exists and is valid
regenerate_cert=false

if [ ! -f /etc/nginx/certs/foundry.crt ] || [ ! -f /etc/nginx/certs/foundry.key ]; then
    echo "SSL certificate not found, will generate..."
    regenerate_cert=true
else
    # Check if certificate is expired or will expire in next 30 days
    if sudo openssl x509 -checkend 2592000 -noout -in /etc/nginx/certs/foundry.crt 2>/dev/null; then
        echo "[OK] SSL certificate is valid"
    else
        echo "[WARN] SSL certificate is expired or expiring soon, will regenerate..."
        regenerate_cert=true
    fi
fi

# Generate or regenerate SSL certificate
if [ "$regenerate_cert" = true ]; then
    echo "Generating self-signed SSL certificate..."
    sudo openssl req -x509 -nodes -days 3650 -newkey rsa:2048 \
        -keyout /etc/nginx/certs/foundry.key \
        -out /etc/nginx/certs/foundry.crt \
        -subj "/C=US/ST=State/L=City/O=Organization/CN=$foundry_hostname" \
        2>/dev/null
    echo "[OK] SSL certificate generated (valid for 10 years)"

    # Reload nginx if it's running to use new certificate
    if systemctl is-active --quiet nginx 2>/dev/null; then
        sudo systemctl reload nginx 2>/dev/null || true
        echo "[OK] nginx reloaded with new certificate"
    fi
fi

# Create nginx configuration
echo "Creating nginx configuration..."
sudo tee /etc/nginx/sites-available/foundry >/dev/null << NGINXEOF
server {
  listen 80 default_server;
  server_name _;
  return 301 https://\$host\$request_uri;
}

server {
  listen 443 ssl default_server;
  server_name _;

  ssl_certificate     /etc/nginx/certs/foundry.crt;
  ssl_certificate_key /etc/nginx/certs/foundry.key;

  client_max_body_size 300m;

  location / {
    proxy_pass http://127.0.0.1:30000;
    proxy_http_version 1.1;

    proxy_set_header Host \$host;
    proxy_set_header X-Real-IP \$remote_addr;
    proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto \$scheme;

    proxy_set_header Upgrade \$http_upgrade;
    proxy_set_header Connection "upgrade";
  }
}
NGINXEOF

# Enable the site
sudo ln -sf /etc/nginx/sites-available/foundry /etc/nginx/sites-enabled/foundry

# Remove other nginx sites that might conflict
sudo rm -f /etc/nginx/sites-enabled/default
sudo rm -f /etc/nginx/sites-enabled/canticle.local

# Test nginx configuration
if sudo nginx -t 2>/dev/null; then
    echo "[OK] nginx configuration valid"
else
    echo "[ERROR] nginx configuration invalid"
    exit 1
fi

# Restart nginx
echo "Starting nginx..."
sudo systemctl restart nginx
sudo systemctl enable nginx
echo "[OK] nginx configured and running"

# Check if Foundry is already initialized
echo
# Get the actual volume name created by Docker Compose (includes project name prefix)
VOLUME_NAME=$(docker compose config --format json | grep -o '"foundry_data"' | head -1 | tr -d '"' || echo "foundry_data")
FULL_VOLUME_NAME="$(basename $(pwd) | tr '[:upper:]' '[:lower:]')_${VOLUME_NAME}"

# Get version from .env if it exists
if [ -f .env ]; then
    CURRENT_VERSION=$(grep -E "^FOUNDRY_DOCKER_TAG=" .env | cut -d'=' -f2- | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | sed 's/#.*//')
    VERSION_MSG="version: ${CURRENT_VERSION:-release}"
else
    VERSION_MSG="selected version"
fi

if docker volume ls --format '{{.Name}}' | grep -q "^${FULL_VOLUME_NAME}$"; then
    echo "[INFO] Checking for existing Foundry installation..."

    # Check if the volume has been initialized (has Data or Config directories)
    if docker run --rm -v "${FULL_VOLUME_NAME}:/data" alpine test -d /data/Data 2>/dev/null; then
        echo "[OK] Foundry VTT is already initialized"
        echo "     Already using ${VERSION_MSG}"
    else
        echo "[INFO] First container startup - Foundry will initialize"
        echo "      Using ${VERSION_MSG}"
    fi
else
    echo "[INFO] First installation - setting up Foundry VTT"
    echo "      Will use ${VERSION_MSG}"
fi

# Check if Foundry Docker image needs updating
echo

# Get current image ID if it exists
current_image=$(docker images -q "felddy/foundryvtt:${foundry_docker_tag}" 2>/dev/null)

if [ -z "$current_image" ]; then
    # First time - must pull
    echo "Downloading Foundry Docker image..."
    docker compose pull foundry
    needs_rebuild=true
else
    # Image exists - ask if user wants to check for updates
    echo "Foundry Docker image found locally."
    read -p "Check for Foundry updates? [y/N]: " check_updates
    check_updates=${check_updates:-N}

    if [[ "$check_updates" =~ ^[Yy]$ ]]; then
        echo "Checking for updates..."

        # Pull latest image
        docker compose pull foundry 2>/dev/null || true

        # Get new image ID
        new_image=$(docker images -q "felddy/foundryvtt:${foundry_docker_tag}" 2>/dev/null)

        # Check if image changed
        if [ "$current_image" != "$new_image" ]; then
            echo "[INFO] New Foundry version available - will rebuild containers"
            needs_rebuild=true
        else
            echo "[OK] Foundry image is up to date"
        fi
    else
        echo "[OK] Skipping update check - using existing image"
    fi
fi

# Start the containers
echo
echo "=== Starting Foundry VTT ==="
echo

# Start or update containers
# Docker Compose will automatically recreate containers when:
# - Configuration changed (compose.yml or .env)
# - Image changed (new version pulled)
docker compose up -d

if [ "$needs_rebuild" = true ]; then
    echo "[OK] Containers updated with latest images"
else
    echo "[OK] Containers started"
fi

echo
echo "=== Setup Complete ==="
echo
echo "Foundry VTT is now starting. It may take a few minutes to download and initialize."
echo
echo "Access Foundry at: https://$foundry_hostname"
echo "  (Note: You'll see a security warning due to the self-signed certificate)"
echo "  (Click 'Advanced' and 'Proceed' to accept the certificate)"
echo
echo "Manage your server with:"
echo "  cd $(pwd)"
echo "  ./start   - Start the server"
echo "  ./stop    - Stop the server"
echo "  ./logs    - View server logs"
echo "  ./remove  - Uninstall Foundry VTT"
echo
